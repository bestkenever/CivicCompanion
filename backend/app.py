from fastapi import FastAPI, HTTPException
from typing import List
from models import (
    Story,
    ExplainPolicyRequest,
    ExplainPolicyResponse,
    TakeActionRequest,
    TakeActionResponse,
)
from azure_client import call_policy_explainer

app = FastAPI(
    title="CivicCompanion API",
    description="Backend for CivicCompanion: explain policies and suggest actions.",
    version="0.1.0",
)

# Temporary in-memory data until you wire up Azure DB / AI Search
DUMMY_POLICIES = {
    "policy_1": {
        "title": "Student Housing Protection Act",
        "text": (
            "This act introduces new protections for students living in off-campus "
            "housing, including limits on rent increases during the school year, "
            "minimum habitability standards, and clearer eviction procedures."
        ),
        "tags": ["housing", "students", "local"],
    }
}

DUMMY_STORIES: List[Story] = [
    Story(
        id="story_1",
        title="New protections for student renters take effect this semester",
        summary=(
            "A new policy limits rent hikes and sets habitability standards "
            "for students in off-campus housing."
        ),
        policy_id="policy_1",
        tags=["housing", "students", "local"],
    ),
]


@app.get("/health")
async def health_check():
    return {"status": "ok"}


@app.get("/stories", response_model=List[Story])
async def get_stories():
    """
    Returns a list of stories (policy-related updates) for the feed.
    Later, this can query Azure Database for PostgreSQL or Azure AI Search.
    """
    return DUMMY_STORIES


@app.post("/explain-policy", response_model=ExplainPolicyResponse)
async def explain_policy(req: ExplainPolicyRequest):
    """
    Given a policy_id, return:
    - what the policy is
    - what it means for the user
    - a disclaimer

    For now, it uses dummy data + a placeholder Azure OpenAI call.
    """
    policy = DUMMY_POLICIES.get(req.policy_id)
    if not policy:
        raise HTTPException(status_code=404, detail="Policy not found.")

    explanation_text = await call_policy_explainer(
        policy_text=policy["text"],
        user_role=req.user_role,
        language=req.language,
        reading_level=req.reading_level,
    )

    # For now, just reuse the same explanation in both sections.
    # Later, you can parse the model output into structured parts.
    return ExplainPolicyResponse(
        policy_title=policy["title"],
        what_is_this=policy["text"],
        what_it_means_for_you=explanation_text,
        disclaimer=(
            "This explanation is generated by an AI system for educational "
            "purposes only and does not constitute legal or professional advice."
        ),
    )


@app.post("/take-action", response_model=TakeActionResponse)
async def take_action(req: TakeActionRequest):
    """
    Suggest constructive, neutral actions the user can take related to a policy.
    This will later use location + resources from your DB.
    """
    policy = DUMMY_POLICIES.get(req.policy_id)
    if not policy:
        raise HTTPException(status_code=404, detail="Policy not found.")

    # TODO: later, query DB for local orgs, contacts, events based on user_location.
    actions = [
        "Learn more from your local government or university housing office website.",
        "Contact your student union or tenant advocacy group to understand your rights.",
        "Attend a public meeting or info session about housing policies, if available.",
    ]

    return TakeActionResponse(
        policy_title=policy["title"],
        actions=actions,
        disclaimer=(
            "These are general suggestions and may not apply to every situation. "
            "Always verify details with official sources."
        ),
    )
